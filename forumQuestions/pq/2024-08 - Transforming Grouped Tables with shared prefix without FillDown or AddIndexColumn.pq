// BaseData
let
    Source = Table.FromRows(Json.Document(Binary.Decompress(Binary.FromText("i45WMtc31DcyMDJRUNJRCs5PSQTRhgYGBoZghiGYcs7PTgVzQYSBUqwOAW2WIMLIJL8KrskQryYjLHYZEbYLrMQCzDMizS5SHWhMXmCAtZmDeWZE22VCnl0m5NhlSp5dpjjsUlCKjQUA", BinaryEncoding.Base64), Compression.Deflate)), let _t = ((type nullable text) meta [Serialized.Text = true]) in type table [Date = _t, Category = _t, #"Check #" = _t, Item_ID = _t, #"Item Name" = _t, Qty = _t, Modifier_ID = _t]),
   #"Changed Type" = Table.TransformColumnTypes(Source,{{"Date", type date}, {"Category", type text}, {"Check #", Int64.Type}, {"Item_ID", Int64.Type}, {"Item Name", type text}, {"Qty", Int64.Type}, {"Modifier_ID", Int64.Type}})
in
    #"Changed Type"

// FinalTransformed
let
    Source = Table.RemoveColumns( BaseData, { "Modifier_ID" }, MissingField.Ignore ),

    /* this step is generated by PBI when you choose "Group" and "All Rows" */
    #"Grouped Rows" = Table.Group(Source, 
        {"Check #"}, {
            {"Rows", each _, type table [
                Date        = nullable date, 
                Category    = nullable text,
                #"Check #"  = nullable number, 
                Item_ID     = nullable number,
                Item Name   = nullable text,
                Qty         = nullable number,
                Modifier_ID = nullable number 
            ] }
        } ),

    /* 
    For every Table.Group row, transform groups
        - Always take the first record for prefixes
        - Then enumerate the remaining 1 or more rows, expanding into records.
        - or you could use "FillDown" 
    */
    transformRow = (rows as table ) => [
        /* grab the first row */
        base    = rows{0}?,
        /* grab the rest. It's usually 1-to-n rows */
        children = Table.Skip( rows, 1 ),
        
        /* prefix all children using the values from base */
        newRows = Table.TransformRows(
            children, 
            (childRow) => 
                Record.TransformFields( 
                    childRow, {
                        { 
                            "Item_ID",
                            each 
                                Text.From( base[Item_ID]? ) 
                                    &  Text.From( _ )
                        },
                        {
                            "Item Name",
                            each base[Item Name] 
                                & " " 
                                & Text.From( _ )
                        }
                    },
                    MissingField.UseNull 
                )
        ),
        return = newRows
    // ], // toggle these return lines, for easier debugging
    ][return],

    Expand_addColumn = Table.AddColumn( 
        #"Grouped Rows", "To Expand",
        (row) => transformRow( row[Rows] ),
        (type { record })
    ),  
    #"Expanded Step1" = Table.ExpandListColumn( Expand_addColumn, "To Expand" ),

    #"Removed Other Columns" = Table.SelectColumns(
        #"Expanded Step1", { "To Expand" }, MissingField.Error ),
    
    // PBI generates this step when you "expand columns"
    #"Expanded Step2" = Table.ExpandRecordColumn(
        #"Removed Other Columns", "To Expand", 
        { "Date", "Category", "Check #", "Item_ID", "Item Name", "Qty"}, 
        { "Date", "Category", "Check #", "Item_ID", "Item Name", "Qty" }),

    #"Changed Type" = Table.TransformColumnTypes( 
        #"Expanded Step2",{
            {"Date", type date}, {"Category", type text},
            {"Check #", Int64.Type},
            {"Item_ID", Int64.Type},
            {"Item Name", type text},
            {"Qty", Int64.Type }} )
in
    #"Changed Type"